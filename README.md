# ComputerArchitecture_HW2
* [Jserv hw2 link](https://hackmd.io/@sysprog/2023-arch-homework2)
* [Jserv hw1 link](https://hackmd.io/WblzsyE6Q1-1I5MlsTjKOA?view)
* [Jserv lab2 link](https://hackmd.io/@sysprog/SJAR5XMmi)

### Following the instructions in Lab2: RISC-V RV32I[MACF] emulator with ELF support, select one assembly program from Assignment1: RISC-V Assembly and Instruction Pipeline, and adapt it into both RISC-V assembly and C implementations that can be executed flawlessly with rv32emu.
* You must NOT select programs that you have previously submitted.
* You should provide a brief description of your motivations for your selection.
* You may choose to study the same subject as other students, but you must make your own discoveries.
* There are just RV32I instructions that can be used. This means that you MUST build C programs with the -march=rv32i -mabi=ilp32 flags.
    *  RV32M (multiply and divide) and RV32F (single-precision floating point) are not permitted.
* :warning: rv32emu and Ripes may not work together, therefore please be aware of the potential incompatibility. Please check docs/syscall.md and src/syscall.c in advance.
* Do not duplicate workspaces or the entire repository from rv32emu. As a starting point, copy the asm-hello directory instead. You shall modify Makefile and the linker script accordingly.
* kdnvt produced some excellent work that can be used as a benchmark for program analysis and future optimizations. Please read his report carefully and pay attention to certain suggestions and observations.
* (Optional) You have the choice to choose the programs, pi.c and nqueens.c, and create RISC-V assembly that is superior to that produced by GNU Toolchain. That is, your handwritten RISC-V assembly program should run more quickly and occupy less space in the ELF image.

### Disassemble the ELF files produced by the C compiler and contrast the handwritten and compiler-optimized assembly listings.

* You can append the compilation options to experiment. e.g., Change -Ofast (optimized for speed) to -Os (optimized for size).
* Describe your obserations and explain.

### Check the perfcounter for the statistics of your program’s execution. Then, try to optimize the handwritten/generated assembly. You shall read RISC-V Assembly Programmer’s Manual carefully.

* :warning: We care about CSR cycles at the moment.
* Can you improve the assembly code generated by gcc with optimizations? Or, can you write even faster/smaller programs in RISC-V assembly?
* You may drop some function calls and apply techniques such as loop unrolling and peephole optimization.

 
